\documentclass[12pt]{article}
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[T2A]{fontenc}
\usepackage{pscyr} % Нормальные шрифты
\usepackage{cmap} % Улучшенный поиск русских слов в полученном pdf-файле
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage[english, russian]{babel} % Языки: русский, английский
\usepackage{amsmath}
\usepackage{graphicx} %графика
\newcommand{\RomanNumeralCaps}[1]
{\MakeUppercase{\romannumeral #1}}
\begin{document}	
\fontsize{14}{16pt}\selectfont 
\begin{titlepage}
	
	\thispagestyle{empty}
	\begin{center}
		{\bf МИНИСТЕРСТВО ОБРАЗОВАНИЯ РЕСПУБЛИКИ БЕЛАРУСЬ} \vskip 0.2 cm
		{\bf БЕЛОРУССКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ} \vskip 0.2 cm 
		{\bf Механико-математический факультет}\vskip 0.1 cm
		 {Кафедра нелинейного анализа и аналитической экономики}
	\end{center}
	\vskip 1 cm
	\begin{center}
		{Апенко Анастасия Владимировна}
	\end{center}
	
	\begin{center}
		\bf\Large ЧИСЛЕННЫЕ МЕТОДЫ РЕШЕНИЯ ИНТЕГРАЛЬНЫХ УРАВНЕНИЙ
	\end{center}
	\vskip 1.0 cm
	\begin{center}
		{Дипломная работа}\vskip 0.1 cm		
		{студентки \RomanNumeralCaps{4} курса специальности:}\vskip 0.1 cm 
		{ Математика}		
		{(экономическая деятельность)}
	\end{center}
	\vskip 1 cm \hskip 7.1 cm {Научный руководитель: \vskip 0.1 cm} \hskip 6.5 cm {Н.Н.Леонов}
	\vskip 0.1 cm \hskip 6.5 cm {профессор, доктор физ.-мат. наук}  \vskip 1.0 cm
	Допущена к защите \vskip 0.1 cm"\underline{\hskip 0.7 cm}" \underline{\hskip 3 cm} 2019 г. \vskip 0.1 cm заведующий кафедрой профессор \vskip 0.1 cm А.В.Лебедев	
	\vskip 0.6 cm \centerline{Минск}\vskip 0.1 cm \centerline{2019}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\end{titlepage}
	



\begin{titlepage}
	\begin{center}
		
		\textbf{СОДЕРЖАНИЕ}\\
	\end{center}
	\vspace{0.5cm}
	1. ВВЕДЕНИЕ........................................................................\hfill{3}
	\\
	2. ГЛАВА 1. Предобработка изображений......................................\hfill{5}
	\\
	3. ГЛАВА 2. Контроль положения аппликатора
	\\
	2.1 Замена интеграла конечной суммой.................................\hfill{5}
	\\
	2.2 Оценка погрешности ......................................................\hfill{12}
	\\
	2.3 Замена ядра интегрального уравнения вырожденным ядром.........................................................................................\hfill{17}
	\\
	2.4 Приближённое решение интегрального уравнения по методу Бубнова-Галёркина............................................................\hfill{22}
	\\
	2.5 Приближённое решение интегрального уравнения, используя нейронные сети в методе Бубнова-Галёркина..................\hfill{24}
	\\
	3. ПРИМЕНЕНИЕ ТЕОРЕТИЧЕСКОГО МАТЕРИАЛА ПРИ РЕШЕНИИ ЗАДАЧ..............................................................\hfill{27}
	\\
	Метод №1 ............................................................................\hfill{28}
	\\
	Компьютерная реализация..................................................\hfill{32}
	\\
	Метод №2 ............................................................................\hfill{37}
	\\
	Компьютерная реализация..................................................\hfill{40}
	\\
	Метод №3 ...........................................................................\hfill{45}
	\\
	Компьютерная реализация.....................................................\hfill{48}
	\\
	Метод №4..........................................................................\hfill{51}
	Компьютерная реализация....................................................\hfill{53}
	\\
	4. Заключение .....................................................................\hfill{58}
	\\
	5. Список литературы .........................................................\hfill{59}
	\\
\end{titlepage}
\setcounter{page}{3}
\begin{center}
	\textbf{ВЕДЕНИЕ}\\
\end{center}

\begin{flushright}
	\textit{"Математику уже затем учить надо, что она ум в порядок приводит."}\\
	М.В. Ломоносов
\end{flushright}



\newpage
\begin{center}
	\textbf{ТЕОРИТИЧЕСКОЕ ВВЕДЕНИЕ}\\
\end{center}
\begin{center}
	\textbf{$ \S $2.1 Замена интеграла конечной суммой }
\end{center}
\begin{flushright}
\textit{	"Всякое правильное рассуждение можно\\
	 свести к систематическому применению\\
	 небольшого числа неизменных правил,\\
	 не зависящих от конкретной природы объектов,\\
	 о которых идёт речь."}\\
	Н. Бурбаки
\end{flushright}

$$ \ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast $$ \\

В этой главе мы рассмотрим те особые методы, которые будем использовать для обработки исходных медицинских изображений, содержащие меланомы. Обозначим цели, проведём классификацию,подробно опишем каждый алгоритм, а также выясним, почему выбрали тот, а не иной метод для данных снимков.\\

Начнём с того, что определим важность предобработки изображений для дальнейшей успешной работы с ними. 
Первым шагом является получение цифрового изображения с использованием датчиков в оптических или тепловых длинах волн. Двумерное изображение, которое регистрируется этими датчиками, является отображением трехмерного визуального мира. Захваченные двумерные сигналы дискретизируются и квантуются для получения цифровых изображений.
Довольно часто мы получаем зашумленные изображения, которые ухудшаются из-за какого-то механизма ухудшения качества.
Выделяют следующие источники шума:\\
\begin{itemize}
	\item некачественное оборудование для захвата изображения (видеокамера, ТВ-тюнер, сканер и т.д.)
	\item плохие условия съёмки (ночная фото/видеосъемка, дождь,..)
	\item помехи, возникающие при передаче по аналоговым каналам, т.е. собственные шумы активных компонентов (усилителей) линии передачи
	\item повреждение информации на носителе или искажение данных при их передаче через цифровые каналы
	\item неточности при выделении яркостного и цветоразностных сигналов из аналогового композитного сигнала и т.п.
	\item энергетические помехи из-за беспорядочно распределённых отражателей сигнала, слишком мелких для того, чтобы их могла отобразить система 
\end{itemize}
Таким образом, важно понимать методы хранения, обработки, передачи, распознавания и, наконец, интерпретации таких визуальных сцен.
$$ \ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast\ast $$ \\

В этом параграфе мы рассмотрим решение уравнений Фредгольма второго рода методом замены интеграла конечной суммой. 

\textbf{Определение 2.1} \textit{Интегральным уравнением Фредгольма второго рода} называется уравнение вида:\\
$$ y(x) - \lambda \int\limits_a^b K(x, s) y(s) ds = f(x), \quad (\star) $$ \\
где $ f(x) $ и $ K(x, s) $ — заданные функции, а $ y(x) $ — искомая функция.\\ 

Решение интегральных уравнений Фредгольма включает в себя следующие две части: \\

$ 1) $ отыскание решения неоднородного интегрального уравнения при заданном значении параметра $ \lambda $ и заданной правой части $ f(x) $;\\

$ 2) $ отыскание собственных значений и собственных функций ядра $ K(x, s) $, т. е. отыскание таких значений параметра $ \lambda $, при которых однородное уравнение\\
$$ y(x) - \lambda \int\limits_a^b K(x, s) y(s) ds = 0  \quad (1)$$ \\
имеет нетривиальное решение $ y(x) $. Эти значения $ \lambda $ и соответствующие им нетривиальные решения называются, соответственно, \textit{собственными значениями} и \textit{собственными функциями} ядра $ K(x,s) $. \\

Для начала положим, что ядро $ K(x,s) $ и правая часть $ f(x) $ непрерывны и имеют непрерывные производные до некоторого порядка. Следовательно и решение уравнения имеет производные до того же порядка.\\

Для решения заданного интегрального уравнения $ (\star) $ можно применять метод замены интеграла, входящего в уравнение, конечной суммой, используя для этого известные квадратурные формулы. \\

Рассмотрим квадратурную формулу:\\
$$ \int\limits_a^b F(x) dx = \sum\limits_{j=1}^n A_{j}F(x_{j}) + R(F) . \quad (2)$$ \\
где абсциссы $ x_{1}, x_{2}, ..., x_{n} $, принадлежащие отрезку $ [a,b] $, и коэффициенты $ A_{1}, A_{2}, ..., A_{n} $ не зависят от выбора функции $ F(x) $, a $ R(F) $ — остаточный член квадратурной формулы. Положим в интегральном уравнении $ (\star) \quad x = x_{i} \: (i = 1, 2, ..., n) $. Тогда:\\
$$ y(x_{i}) - \lambda\int\limits_a^b K(x_{i}, s) y(s) ds = f(x_{i}) \quad (i = 1, 2, ..., n) \quad (3) $$\\
Заменим в $ (3) $ интеграл с помощью квадратурной формулы $(2) $.\\ 
Будем иметь: \\
$$ y(x_{i}) - \lambda\sum\limits_{j=1}^n A_{j}K(x_{i}, x_{j}) y(x_{j}) ds = f(x_{i}) + \lambda R_{i}; \quad (4)$$\\
 $$\quad R_{i} = R[K(x_{i}, s)y(s)]  $$\\
Отбрасывая в системе $ (4) \quad \lambda(R_{i}) $, получим для отыскания приближенных значений $ Y_{i} $ решения $ y(x) $ в узлах $ x_{1}, x_{2}, ..., x_{n} $ линейную систему алгебраических уравнений:\\
$$ Y_{i} - \lambda\sum\limits_{j=1}^n A_{j}K_{ij}Y_{j} = f_{i} \quad (i = 1, 2, ..., n) \quad (5) $$\\
где введены обозначения $ K_{ij} = K(x_{i},x_{j}), \: f_{i} = f(x_{i})$. Решив эту систему, мы найдем значения $ Y_{1}, Y_{2}, ..., Y_{n} $, по которым процессом интерполяции можно получить приближенное решение интегрального уравнения $ (\star) $ на всем отрезке $ [a,b] $. За аналитическое выражение приближенного решения уравнения $ (\star) $ можно принять функцию:\\
$$ Y(x) = f(x) + \lambda\sum\limits_{j=1}^n A_{j}K(x,x_{j})Y_{j} \quad (6)$$\\
принимающую в узлах $ x_{1},x_{2},..., x_{n} $ значения $ Y_{1}, Y_{2},..., Y_{n} $. \\
\begin{center}
\textbf{	В качестве квадратурных формул можно рассмотреть следующие варианты.}
\end{center}
$ \bullet $ \textbf{Вариант 1}: обобщенная 
формула прямоугольников\\
$$ x_{1} = a; \: x_{2} = a+h; ...; \: x_{n} = a+(n-1)h;  $$\\
$$ A_{1} = A_{2} = ... = A_{n} = \frac{b-a}{n};  $$\\
$ \bullet $ \textbf{Вариант 2}: обобщенная формула трапеций\\
$$ x_{1} = a; \: x_{2} = a+h; ...; \: x_{n} = a+(n-1)h = b; \quad (h = \frac{b-a}{n-1}); $$\\
$$ A_{1} = A_{n} = \frac{h}{2}; \: A_{2} = A_{3} = ... = A_{n-1} = h; $$\\
$ \bullet $ \textbf{Вариант 3}: обобщенная формула Симпсона, где $ n=2m+1 $: \\
$$  x_{1} = a; \: x_{2} = a+h; ...; \: x_{2m+1} = a+2mh = b; \quad (h = \frac{b-a}{2m}); $$\\
$$ A_{1} = A_{2m+1} = \frac{h}{3}; \: A_{2} = A_{4} = ... = A_{2m} = \frac{4h}{3}; $$\\
$$ A_{3} = A_{5} = ... = A_{2m-1} = \frac{2h}{3};  $$\\
\textbf{Замечание 2.1.1} \\
Этот метод может быть применен и для решения нелинейных интегральных уравнений вида:\\
$$ \int\limits_a^b K(x,s,y(x),y(s))ds = f(x) \quad (7) $$\\
но в этом случае вместо системы $ (5) $ получим систему: \\
$$ \sum\limits_{j=1}^n A_{j}K(x_{i},x_{j}; Y_{i}, Y_{j}) = f_{i} \quad (i =1,2, ..., n) \quad (8) $$\\
которая уже будет нелинейной.\\

Вернемся к интегральному уравнению $ (\star) $: \\

$ \checkmark $ Если это уравнение однородно, то и система $ (5) $ будет \textit{однородной системой}. \\

$ \checkmark $ Она будет иметь нетривиальное решение \textit{в том и только в том случае}, когда определитель системы $ (5) $ равен нулю. Приравнивая нулю этот определитель, получим алгебраическое уравнение степени $ n $ относительно $ \lambda $. Решая это уравнение, найдем $ n $ корней $ \bar{\lambda_{1}}, \bar{\lambda_{2}}, ..., \bar{\lambda_{n}} $, которые будут приближенными значениями первых $ n $ собственных значений ядра $ K(x,s) $. Подставляя в однородную систему, соответствующую системе $ (5) $, одно из найденных значений $ \bar{\lambda_{i}} $ и находя линейно независимые решения этой системы, получим приближения к линейно независимым собственным функциям ядра $ K(x,s) $, соответствующим данному собственному значению.\\

$ \checkmark $ Если $ \lambda $ не равно ни одному из этих корней, то однородная система имеет \textit{только тривиальное решение}, а система $ (5) $ — \textit{единственное решение}. \\

$ \checkmark $ При выборе квадратурной формулы в этом методе нужно иметь в виду, что чем более точную формулу мы применяем, тем большую гладкость ядра и решения, а следовательно и $ f(x) $, нужно требовать. Попытка применения более точных квадратурных формул для получения более точного приближения при несоблюдении этого условия может привести совсем к обратному результату. \\

В случае, если правая часть или ядро $ K(x,s) $ (или их производные) имеет особенности, целесообразно предварительно выполнить некоторые преобразования с тем, чтобы получить более хорошее интегральное уравнение, с помощью которого можно будет получить более точное приближенное решение исходного уравнения. Для этого могут быть полезны следующие приемы.\\

Если ядро гладкое, а правая часть $ f(x) $ имеет особенности, то можно вместо $ y(x) $ ввести новую неизвестную функцию:\\
$$ z(x) = y(x) - f(x) .$$\\
Подстановка ее в уравнение дает:\\
$$ z(x) - \lambda\int\limits_a^b K(x,s)z(s)ds = \lambda\int\limits_a^b K(x,s)f(s) ds ,$$ \\
т. е. мы получим уравнение в точности того же вида, но в котором правая часть будет уже более гладкой, а следовательно, и решение $ z(x) $ будет более гладким. Найдя $ z(x) $, затем найдем и искомое решение $ y(x) $. \\

Очень часто встречаются уравнения, в которых ядро $ K(x,s) $ или его производная по $ s $ имеет разрывы на диагонали $ x = s $. В этом случае уравнение предварительно выгодно переписать в виде:\\
$$ y(x)\left[ 1- \lambda\int\limits_a^b K(x,s) ds \right] - \lambda\int\limits_a^b K(x,s)[y(s) - y(x)]ds = f(x) .  $$\\
Подынтегральная функция во втором интеграле будет правильной, так как на диагонали $ x = s $ разность $ y(s) - y(x) $ обращается в нуль, а $ \int\limits_a^b K(x,s) ds $ уже не будет содержать неизвестной функции и его часто можно вычислить в явном виде. Применение метода к этому последнему интегральному уравнению даст лучший результат. \\

Часто встречаются интегральные уравнения с ядрами вида:\\
$$ K(x,s) = \frac{H(x,s)}{|x-s|^{\alpha}} \quad (0 < \alpha < 1) , $$ \\
где $ H(x,s) $ — гладкая функция. От уравнений с такими ядрами целесообразно перейти к уравнениям с итерированными ядрами, которые уже не будут иметь особенности при $ x = s $.  \\
\newpage
\begin{center}
	\textbf{$ \S $2.2 Оценка погрешности }
\end{center}
\begin{flushright}
	\textit{	"Всякое рассуждение должно приводиться\\
		в определенной, чётко ограниченной\\
		области предметов, которую следует\\
		заранее указать и которая не может быть всеобъемлющей."}\\
	Э. Шредер
\end{flushright}

Рассмотрим теперь вопрос об оценке погрешности решения, получаемого по методу замены интеграла конечной суммой, предполагая в уравнении $ (\star) $ наличие у ядра $ K(x,s) $ и правой части $ f(x) $ непрерывных производных до порядка $ q $. Тогда и решение будет иметь непрерывные производные до порядка $ q $.\\

Если обозначить определитель системы $ (5) $ через $ D(\lambda) $, а алгебраические дополнения его элементов через $ D_{ij}(\lambda) $, то решение системы $ (5) $ можно будет записать в виде:\\
$$ Y_{i} = \frac{1}{D(\lambda)}\sum\limits_{j=1}^n D_{ij}f_{j} \quad (9) $$\\
Из системы $ (4) $ будем иметь: \\
$$  y(x_{i}) = \frac{1}{D(\lambda)}\sum\limits_{j=1}^n D_{ij}(f_{j} + \lambda R_{j}) \quad (9')$$\\
Обозначим через $ \eta_{i} $ погрешность приближенного решения в точке $ x_{i} $, т. е. \\
$$ \eta_{i} = y(x_{i}) - Y_{i} ,$$\\
а через $ \eta(x) $ обозначим разность $ y(x) - Y(x) $, где $ Y(x) $ определяется формулой $ (6) $. Тогда из $ (9) $ и $ (9') $ имеем: 
$$ \eta_{i} = y(x_{i}) - Y_{i} = \frac{\lambda}{D(\lambda)}\sum\limits_{j=1}^n D_{ij}Rj .$$\\
Если ввести обозначения:\\
$$ B = \max_i \frac{\sum\limits_{j=1}^n|D_{ij}|}{|D(\lambda)|}; \; \rho = \max\limits_{a\leqslant x \leqslant b}|R|; \; R = R[K(x,s)y(s)] $$\\
то:\\
$$ |\eta_{i}| \leqslant |\lambda| B\rho . \quad (10)$$ \\
Для $ \eta(x) $ получим следующее равенство: \\
$$ \eta(x) = y(x) - Y(x) = \lambda \sum\limits_{j=1}^n A_{j}K(x,x_{j})y(x_{j}) + \lambda R - \lambda \sum\limits_{j=1}^n A_{j}K(x,x_{j})Y_{j} . $$\\
Отсюда получается следующая оценка:\\
$$ |\eta(x)| \leqslant |\lambda|\sum\limits_{j=1}^n |A_{j}||K(x,x_{j}||y(x_{j}) - Y_{j}| + |\lambda||R| $$\\
или\\
$$ |\eta(x)| \leqslant |\lambda|\rho + |\lambda|^2 M_{0}B\rho \sum\limits_{j=1}^n |A_{j}|; \quad  M_{0} = \max\limits_{a \leqslant x,s \leqslant b} |K(x,s)| \quad (10') $$ \\

В оценках $ (10) $ и $ (10') $ все константы могут быть вычислены, кроме константы $ \rho $. Константа $ \rho $ есть максимум абсолютной величины остаточного члена квадратурной формулы для $ F = K(x,s) y(s) $ при всех $ x\in [a,b] $. Для формул трапеций, Симпсона, Гаусса и многих других остаточный член имеет вид:\\
$$ R(F) = k_{n}F^{(m)}(\xi) ,$$\\
где $ k_{n} $ — некоторая постоянная, зависящая от $ n $, а $ \xi $ — некоторая точка отрезка $ [a,b] $. Таким образом:\\
$$ |R(F)| \leqslant k_{n}\max\limits{[a,b]}|F^{(m)}(s)| . $$\\
В нашем случае $ F(s) = K(x,s)y(s) \; $ ($ x $ — параметр). Таким образом:\\
$$ F^{(m)}(s) = \sum\limits_{k=0}^m C_m^k \frac{\partial^{k}K(x,s)}{\partial s^{k}} y^{(m-k)} , $$ \\
а\\
$$ \max\limits_{[a,b]} |F^{(m)}(s)| \leqslant \sum\limits_{k=0}^m C_m^k M_k N_{m-k} , $$\\
где введены обозначения:\\
$$ M_k = \max\limits_{a \leqslant x,s \leqslant b } \left\lbrace \left| \frac{\partial^{k}K(x,s)}{\partial x^{k}} \right|, \left| \frac{\partial^{k}K(x,s)}{\partial s^{k}} \right|  \right\rbrace ; \quad N_k = \max\limits_{a \leqslant s \leqslant b} |y^{(k)}(s)|. \quad (11)   $$ \\
Постоянные $ N_k $ нам неизвестны, так как неизвестно решение. Но их можно оценить. Для этого продифференцируем интегральное уравнение $ (\star) \; k $ раз. Будем иметь: \\
$$ y^{(k)}(x) = \lambda \int\limits_a^b \frac{\partial^{k}}{\partial x^{k}} K(x,s)y(s)ds + f^{(k)}(x) , $$\\
откуда\\
$$ |y^{(k)}(x)| \leqslant |\lambda| M_{k}(b-a)N_0 + P_k; \quad P_k = \max\limits_{a\leqslant k \leqslant b} |f^{(k)}(x)| $$\\
или\\
$$ N_k \leqslant |\lambda|M_k (b-a)N_0 + P_k . $$\\
Таким образом,\\
$$ \max\limits_{a \leqslant s \leqslant b}|F^{(m)}(s)| \leqslant |\lambda| N_0(b-a)\sum\limits_{k=0}^m C_m^k M_k M_{m-k} + \sum\limits_{k=0}^m C_m^k M_k P_{m-k} = C_1 N_0 + C_2 . \: (12) $$\\
где\\
$$ C_1 = |\lambda|(b-a)\sum\limits_{k=0}^m C_m^k M_k M_{m-k}; \quad C_2 = \sum\limits_{k=0}^m C_m^k M_k P_{m-k} \quad (13) $$\\
— постоянные величины, которые можно найти, так как ядро $ K(x,s) $ и $ f(x) $ известны. Обозначим через $ Q_0 $ максимум абсолютной величины приближенного решения $ Y(x) $. Из оценки $ (10') $ будем иметь: \\
$$ |y(x)| \leqslant |\eta(x)| + |Y(x)| \leqslant |\lambda|\rho + |\lambda|^2 M_2 B\rho \sum\limits_{j=1}^n |A_j| + Q_0 \leqslant$$ 
\\
 $$\leqslant \left\lbrace |\lambda| + |\lambda|^2M_0B\sum\limits_{j=1}^n |A_j|\right\rbrace k_n (C_1 N_0 + C_2) + Q_0  $$\\
или\\
$$ N_0 \leqslant \left\lbrace |\lambda| + |\lambda|^2 M_0B\sum\limits_{j=1}^n |A_j|\right\rbrace k_n (C_1 N_0 + C_2) + Q_0 .  $$\\
Если\\
$$ 1 - k_n \left\lbrace |\lambda| + |\lambda|^2 M_0B\sum\limits_{j=1}^n |A_j| \right\rbrace C_1 > 0 ,  $$\\
то\\
$$ N_0 \leqslant \frac{Q_0 + k_nC_2 \left\lbrace  |\lambda| + |\lambda|^2 M_0B\sum\limits_{j=1}^n |A_j| \right\rbrace }{1 - k_nC_1 \left\lbrace |\lambda| + |\lambda|^2 M_0B\sum\limits_{j=1}^n |A_j| \right\rbrace } . \quad (14) $$\\
Следовательно, погрешности $ \eta_i $ и $ \eta(x) $ можно оценить через известные величины. \\

Напомним, что: \\
\begin{itemize}
	 \item   для обобщенной формулы трапеции с $ n $ ординатами $ k_n = \frac{(b-a)^3}{12(n-1)^2}, \; m=2 $; \\
	 \item   для обобщенной формулы Симпсона с $ n=2p+1 $ ординатами $ k_n = \frac{(b-a)^5}{90(2p)^4}, \; m=4 $; \\
	 \item   для формулы Гаусса с $ n $ ординатами $ k_n = \frac{(b-a)^{2n+1}(n!)^4}{[(2n)!]^3(2n+1)}, \; m = 2n $ .
\end{itemize}

\newpage
\begin{center}
	\textbf{$ \S $2.3 Замена ядра интегрального уравнения вырожденным ядром }
\end{center}
\begin{flushright}
	\textit{"Для понятий, которые кажутся\\
		близкими к чувствунной интуиции,\\
		соответствующие математические объекты,\\
		в сущности, очень отличаются от того,\\
		что мы о них думаем."}\\
	Ж. Дьедонне
\end{flushright}

В этом параграфе мы рассмотрим решение уравнений Фредгольма второго рода методом замены ядра интегрального уравнения вырожденным ядром. \\

Если в уравнении $ (\star) $ ядро $ K(x,s) $ вырожденное, то решение этого уравнения может быть найдено в конечном виде. Пусть ядро представимо в виде:\\
$$ K(x,s) = \sum\limits_{i=1}^n A_i(x)B_i(s) .$$\\
Можно считать, что $ A_1(x), A_2(x), ..., A_n(x) $ и $ B_1(x), B_2(x), ..., B_n(x) $ суть системы линейно независимых на отрезке $ [a,b] $ функций. Так как интегральное уравнение будет иметь вид:\\
$$ y(x) - \lambda\sum\limits_{i=1}^n A_i(x)\int\limits_a^nB_i(s)y(s) ds = f(x),  \quad (15) $$\\
то решение его можно искать в виде:\\
$$ y(x) = f(x) + \lambda \sum\limits_{i=1}^n C_iA_i(x) , $$\\
где $ C_i $ — некоторые постоянные. Подставляя $ y(x) $ в уравнение $ (15) $ и сокращая на $ \lambda $, получим: \\
$$ \sum\limits_{i=1}^n C_iA_i(x) - \lambda\sum\limits_{i=1}^n A_i(x) \sum\limits_{j=1}^nC_j\int\limits_a^bA_j(s)B_i(s)ds - $$\\
$$- \sum\limits_{i=1}^n A_i(x) \int\limits_a^b f(s) B_i(s)ds = 0 .$$\\
Вводя обозначения:\\
$$ f_i = \int\limits_a^b f(s)B_i(s)ds; \quad \alpha_{ij} = \int\limits_a^b A_j(s)B_i(s)ds $$\\
и принимая во внимание линейную независимость функций $ A_1(x), A_2(x), ..., A_n(x) $ для отыскания $ C_i \; (i=1,2, ..., n), $, получим систему линейных алгебраических уравнений:\\
$$ C_i - \lambda\sum\limits_{j=1}^n \alpha_{ij}C_j = f_i \quad (i=1,2, ..., n). \quad (16)$$ \\

$ \checkmark $ Если определитель системы $ (16) $ отличен от нуля, то система имеет единственное решение для $ C_1, C_2, ..., C_n $ и решение интегрального уравнения $ y(x) $ будет найдено в явном виде.\\

$ \checkmark $ Если же при данном значении $ \lambda $ определитель $ D(\lambda) $ равен нулю, то $ \lambda $ будет собственным значением ядра $ K(x,s) $. В этом случае, находя все линейно независимые решения соответствующей однородной системы, мы в явном виде найдем все линейно независимые между собой собственные функции ядра  $ K(x,s) $, соответствующие данному собственному значению $ \lambda $.\\ 

Метод приближенного решения интегральных уравнений Фредгольма с помощью замены ядра близким к нему вырожденным ядром основан на следующей теореме: \\
\\
\textbf{Теорема 2.3} \\

Если \\
$$ y(x) - \lambda\int\limits_a^b K(x,s)y(s)ds = f(x), \quad (17) $$\\
$$ z(x) - \lambda\int\limits_a^b H(x,s)z(s)ds = f_1(x) \quad (18) $$\\
— два интегральных уравнения, $ R(x,s,\lambda) $ — резольвента второго из этих уравнений и существуют такие константы $ \delta,\, \varepsilon, \, M $, что имеют место неравенства:\\
$$ \int\limits_a^b |K(x,s) - H(x,s)|ds < \delta, \quad (19) $$\\
$$ |f(x) - f_1(x)| < \varepsilon , \quad (20) $$\\
$$ \int\limits_a^b |R(x,s,\lambda)|ds < M \quad (21) $$\\
\\
и выполнено условие:\\
$$ |\lambda|\delta(1 + |\lambda|M)<1, \quad (22) $$\\
то уравнение $ (17) $ имеет единственное решение $ y(x) $ и \\
$$ |y(x) - z(x)| < \frac{N|\lambda|(1 + |\lambda|M)^2\delta}{1 - |\lambda|\delta(1 + |\lambda|M)} + \varepsilon(1 + |\lambda|M), \quad (23) $$ \\
где $ N = \max\limits_{a\leqslant x \leqslant b}|f(x)| $.\\
\\

Из теоремы следует, что если можно построить достаточно близкое к ядру $ K(x,s) $ вырожденное ядро $ H(x,s) $, то, решив уравнение с вырожденным ядром $ H(x,s) $, мы получим решение, близкое к решению уравнения с ядром $ K(x,s) $ при той же правой части. Более того, если мы построим последовательность вырожденных ядер 
$ H_n(x,s) $, равномерно сходящуюся к ядру $ K(x,s) $, то последовательность решений $ z_n(x) $ уравнений с ядрами $ H_n(x,s) $ будет равномерно сходиться к решению $ y(x) $ уравнения с ядром $ K(x,s) $.\\ 

Способы построения вырожденных ядер, близких к данному ядру $ K(x,s) $, могут быть самыми различными. Например, ядро $ K(x,s) $ можно приближать частичными суммами степенного или двойного тригонометрического ряда, если ядро $ K(x,s) $ разлагается в равномерно сходящийся в прямоугольнике $ a \leqslant x, \: s \leqslant b $ степенной или тригонометрический ряд, или приближать его алгебраическими или тригонометрическими интерполяционными многочленами.\\ 

Иногда целесообразно приближать ядро не вырожденным ядром, а суммой вырожденного ядра и ядра с известной резольвентой. Тогда приближенное решение уравнения $ (\star) $ может быть записано в виде:\\
$$ y(x) \approx f(x) + \lambda\int\limits_a^b R_n(x,s,\lambda)f(s) ds. $$ \\
\newpage
\begin{center}
	\textbf{$ \S $2.4 Приближённое решение интегрального уравнения по методу Бубнова-Галёркина }
\end{center}
\begin{flushright}
	\textit{"Ценность математики заключается\\
		в их абстрактности и общности."}\\
	А. Уайтхед
\end{flushright}

В этом параграфе мы рассмотрим решение уравнений Фредгольма второго рода методом Бубнова-Галёркина. \\

Выбираем систему функций $ {u_n(x)} $, полную в $ L_2(a,b) $ и такую, что при любом $ n $ функции $ u_1(x), u_2(x), ..., u_n(x) $ линейно независимы, и ищем nриближенное решение $ \varphi_n(x) $ в виде:\\
$$ \varphi_n(x) = \sum\limits_{k=1}^n a_ku_k(x) . \quad (24) $$\\

Коэффициенты $ a_k \; (k = 1,2 , ..., n ) $ определяются из следующей линейной системы :\\
$$ (\varphi_n(x),\, u_k(x)) = (f(x), \, u_k(x)) + \lambda\left( \int\limits_a^b K(x,t)\varphi_n(t)dt, \, u_k(x) \right) \quad (25)$$\\
$$ (k = 1, 2, ..., n), $$\\
где $ (f,g) $ означает $ \int\limits_a^b f(x)g(x)dx $ и вместо $ \varphi_n(x) $ надо nодставить $ \sum\limits_{k=1}^n a_ku_k(x) $. Если значение $ \lambda $ в $ (\star) $ не является характеристическим, то при достаточно больших  $ n $ система $ (25) $ однозначно разрешима и при $ n \rightarrow \infty $ приближенное решение $ \varphi_n(x) \; (24) $ стремится в метрике $ L_2(a,b) $ к точному решению $ \varphi(x) $ уравнения $ (\star) $. \\
\\
\textbf{Замечание 2.4} 

Для вырожденных ядер метод Бубнова-Галёркина дает точное решение, а для общего случая он эквивалентен замене ядра $ K(x,s) $ на вырожденное $ H(x,s) $.\\
\newpage
\begin{center}
	\textbf{$ \S $2.5 Приближённое решение интегрального уравнения, используя нейронные сети в методе Бубнова-Галёркина }
\end{center}
\begin{flushright}
	\textit{"Именно математика ... даёт надежнейшие правила;\\
		кто им следует - тому не опасен обман чувств."}\\
	Л. Эйлер
\end{flushright}

В этом параграфе мы рассмотрим решение уравнений Фредгольма второго рода методом Бубнова-Галёркина, используя нейронные сети.\\

Основываясь на стандартном методе (из $ \S $2.4 ), будем выбирать систему функций, представляющую собой нейронную сеть. Рассмотрим простейший пример нейронной сети - \textit{однослойный персептрон Розенблатта}.\\

Пусть заданы векторы  $w_1,\ldots,w_m\in\mathbb{R}^n$ и числа $a_1,\ldots,a_m,b\in\mathbb{R}$, а также $\theta$~--- функция Хевисайда:\\
$$ \theta(t)=
\begin{cases} 0,\textrm{ если } t<0,\\
1,\textrm{ если } t\geqslant 0.
\end{cases}$$\\

Следовательно функция $ f: \mathbb{R}^n \rightarrow \mathbb{R} $, что:\\
$$ \label{SingleLayerPerceptronOnHilbertSpaceWithHevesideActivationFunction} 
f\left( x\right) \triangleq 
\underset{j=1}{\stackrel{m}{\sum }}a_j \theta(
( w_j,x) -b) $$\\
называется \textit{однослойным персептроном} на $\mathbb{R}^n$ с функцией активации $\theta$. Рассмотрим уравнение:\\
$$ \label{HyperPlaneEquationInBriefForm} 
( w_j,x) -b=0. \quad (26) $$\\

Имеем набор векторов вида: $w_j=(w_{j1},\ldots,w_{jn})$. Тогда уравнение (26) можно переписать в виде

$$\label{HyperPlaneEquationInCoordinateForm}  
\sum\limits_{s=1}^n w_{js} x_s =b, \quad (27)
$$\\
таким образом это уравнение (гипер)плоскости, а функция $\theta(( w_j,x) -b)$ как функция от $x$ представляет собой индикатор полупространства, задаваемого условием $( w_j,x) -b\geqslant 0$, т.\,е. она обращается в нуль с одной стороны от плоскости, и в единицу -- с другой стороны.\\

Рассмотрев нейронную сеть, вернёмся к самому методу решения. Дальнейшие наши действия будут такими, какие были описаны в $ \S $2.4 . Будем выбирать систему функций  $ \theta(
( w_m,x) -b) $ такую, что при любом $ j $ функции $ \theta(
( w_1,x) -b), \theta(( w_2,x) -b), ..., \theta(( w_m,x) -b) $ (называемые \textit{нейронами}) линейно независимы. Приближённое решение будем искать ввиде:\\
$$\label{HyperPlaneEquationInCoordinateForm}  
 \varphi_m(x) = \underset{j=1}{\stackrel{m}{\sum }}a_j 
 \theta(( w_j,x) -b) \quad (28) $$\\

Коэффициенты $ a_j \; (j = 1,2 , ..., m ) $ определяются из следующей линейной системы :\\
$$ (\varphi_m(x),\, \theta(( w_j,x) -b)) = (f(x), \, \theta(( w_j,x) -b)) +$$ \\
 $$ +\lambda\left( \int\limits_a^b K(x,t)\varphi_m(t)dt, \, \theta(( w_j,x) -b) \right) \quad (29)$$\\
$$ (j = 1, 2, ..., m), $$\\
где $ (f,g) $ означает $ \int\limits_a^b f(x)g(x)dx $ и вместо $ \varphi_m(x) $ надо nодставить $ \sum\limits_{j=1}^m a_j\theta(( w_j,x) -b) $.
\newpage 
\begin{center}
	\textbf{ПРИМЕНЕНИЕ ТЕОРЕТИЧЕСКОГО МАТЕРИАЛА ПРИ РЕШЕНИИ ЗАДАЧ}\\
\end{center}
\begin{flushright}
	\textit{	"Истина не передаётся - она добывается."\\}
	В.Ф. Одоевский
\end{flushright}

Рассмотрим интегральные уравнения Фредгольма второго рода:
$$ y(x) - \lambda \int\limits_a^b K(x, s) y(s) ds = f(x), \quad (\star) $$ \\
где $ f(x) $ и $ K(x, s) $ — заданные функции, а $ y(x) $ — искомая функция.\\

Возьмём для исследования следующее уравнение:\\
$$ \varphi(x) + \int\limits_0^1 x(e^{xt}-1)\varphi(t) dt = e^{x} - x  \quad  (\ast)$$\\

Решим его, при помощи трёх основных методов приближенного решения интегральных уравнений.
\\
\newpage
\begin{center}
	\underline{Метод № 1}\\
	\begin{center}
		Найти решение интегрального уравнения:\\
		$$ \varphi(x) + \int\limits_0^1 x(e^{xt}-1)\varphi(t) dt = e^{x} - x  \quad  (\ast)$$\\
		методом замены интеграла конечной суммой. 	
	\end{center}	
	\underline{Решенеие}\\
\end{center}
Возьмём на отрезке $ [0, 1] $ три точки $ x_1 = 0; \; x_2 = 0,5; \; x_3 = 1  $ и положим в уравнении $ (\ast) \quad x = 0; \; x = 0,5; \; x =1 .$\\
Воспользуемся обобщенной формулой трапеций, при $ n = 3 $:
\\
$$ h = \frac{b-a}{n-1} = \frac{1}{2} \quad  x_1 = 0; \: x_2 = \frac{1}{2}; \: x_3 = 1; $$\\
\begin{equation*}
	\begin{cases}
		A_1 = A_3 = \frac{1}{4}, \\ 
		A_2 = \frac{1}{2}.
	\end{cases}
\end{equation*}\\

Тогда получим систему:\\
\begin{equation*}
\begin{cases}
\varphi(0) = 1, \\ 
\varphi(0,5) + 0,5 \int\limits_0^1 (e^{0,5t} - 1)\varphi(t) dt = e^{0,5} - 0,5 ,  \quad  (\divideontimes)\\
\varphi(1) + \int\limits_0^1 (e^t - 1)\varphi(t)dt = e - 1 \quad (\divideontimes\divideontimes)
\end{cases}
\end{equation*}\\
Заменим каждый из интегралов конечной суммой, воспользовавшись формулой:\\
$$ \int\limits_0^1 \Phi(t)dt \approx \sum\limits_{k=1}^3 A_k\Phi(x_k) = $$\\
$$= \frac{1}{4}\left( \Phi(1) + \Phi(3) \right) + \frac{1}{2}\Phi(2) = \frac{\Phi(1) + 2\Phi(2) + \Phi(3)}{4} = \frac{\Phi(0) + 2\Phi(0,5) + \Phi(1)}{4} . $$\\
Для уравнения $ \divideontimes $ системы подынтегральная функция имеет вид:\\
$$ \Phi(t) = \frac{e^{0,5t}-1}{2}\varphi(t) , $$\\
так что\\
$$\Phi(0) = 0; \quad \Phi(0,5) = \frac{e^{0,25}-1}{2}\varphi(0,5); \quad \Phi(1) = \frac{e^{0,5}-1}{2}\varphi(1). $$\\
Значит,\\
$$ 0,5\int\limits_0^1(e^{0,5t}-1)\varphi(t)dt \approx \frac{e^{0,25}-1}{4}\varphi(0,5) + \frac{e^{0,5}-1}{8}\varphi(1).  $$\\
Для уравнения $ \divideontimes\divideontimes $ системы подынтегральная функция имеет вид:\\
$$ \Phi(t) = (e^{t}-1)\varphi(t) , $$\\
так что\\
$$\Phi(0) = 0; \quad \Phi(0,5) = (e^{0,5}-1)\varphi(0,5); \quad \Phi(1) = (e-1)\varphi(1). $$\\
Следовательно,\\
$$ \int\limits_0^1(e^{t}-1)\varphi(t)dt \approx \frac{e^{0,5}-1}{2}\varphi(0,5) + \frac{e-1}{4}\varphi(1).  $$\\
Подставляя полученные значения, получим линейную систему:\\
\begin{equation*}
\begin{cases}
\varphi(0) = 1, \\ 
\\
\frac{e^{0,25}+3}{4}\varphi(0,5) + \frac{e^{0,5}-1}{8}\varphi(1) = e^{0,5} - 0,5 ,  \\
\\
\frac{e^{0,5}-1}{2}\varphi(0,5) + \frac{e+3}{4}\varphi(1) = e - 1 .
\end{cases}
\end{equation*}\\
Подсчитав коэффициенты, получим систему:\\
\begin{equation*}
\begin{cases}
\varphi(0) = 1, \\ 
\\
1,0710\varphi(0,5) + 0,0810\varphi(1) = 1,1487 ,  \\
\\
0,3243\varphi(0,5) + 1,4295\varphi(1) = 1,7183. 
\end{cases}
\end{equation*}\\
Решая данную систему, получим:\\
$$ \varphi(0) = 1; \quad \varphi(0,5) = 0,999; \quad \varphi(1) = 0,975 . $$\\
За приближенное решение уравнения $ (\ast) $ принимаем функцию:\\
$$ \tilde{\varphi}(x) = e^x - x - \sum\limits_{m=1}^3 A_mx(e^{xx_m}-1)\varphi(x_m) , $$\\
подставляя данные:\\
$$ \tilde{\varphi}(x) = e^x - x - (0,25x(e^{x0}-1)\varphi(0)+0,5x(e^{0,5x}-1)\varphi(0,5)+0,25x(e^{1x}-1)\varphi(1)) = $$\\
$$=  e^x - x - 0,4995x(e^{0,5x}-1)- 0,2437x(e^x - 1) , $$\\
Итог:\\
$$ \tilde{\varphi}(x) = e^x - x(0,4995e^{0,5x} + 0,2437e^x) - 0,2568x . $$\\
Для точек $ x = 0; \; x = 0,5; \; x =1 $ получим:\\
$$ \tilde{\varphi}(0) = 1; \quad  \tilde{\varphi}(0,5) = 0,998739236; \quad \tilde{\varphi}(1) = 0,975500272 . $$\\
Точное решение данного интегрального уравнения $ \varphi(x) \equiv 1 . $ \\
\newpage
\begin{center}
	\textbf{Компьютерная реализация}
\end{center}

Реализуем этот метод на языке Python, чтобы проверить правильность решения, проделанного вручную. Эта реализация поможет нам прорешать заданное уравнение для большего количества точек, что должно поспособствовать улучшению полученных результатов.\\

\begin{center}
	\underline{Метод замены интеграла конечной суммой}
\end{center}

\textit{$ \bullet $подключение необходимых пакетов}\\
from sympy import *\\
from mpmath import *\\
from numpy import *\\
from sympy import integrate, log, exp, cos, oo\\
import math\\
from scipy.special import *\\
from sympy import symbols, diff\\
from numpy.polynomial\\
import legendre as leg\\

\textit{ $ \bullet $   Функция правой части}\\
def f(x):\vskip 0.3cm return exp(x)-x\\
 
 \textit{$ \bullet $ Ядро}\\
 def K(x,t):\vskip 0.3cm return x*(exp(x*t) - 1)\\
 
 \textit{$ \bullet $   Кэффициенты по формуле трапеций}\\
 def An(h, n): \vskip 0.3cm Ai = [] \vskip 0.3cm for k in range(1,n+1): \vskip 0.3cm if (k == 1): \vskip 0.3cm Ai.append(h/2) \vskip 0.3cm elif (k == n): \vskip 0.3cm Ai.append(h/2) \vskip 0.3cm else: \vskip 0.3cm Ai.append(h)\\
 
 return Ai\\
 
 \textit{$ \bullet $                                            Получение приближенного решения}\\
 def summa(x,t,a,b,n): \vskip 0.3cm
\textit{ расчёт квадратурной формулы (формула трапеций) и точек по ней}\\

 h = (b-a)/(n-1) \vskip 0.3cm
 
 xi = [a+(k-1)*h for k in range(1,n+1)]
 
\textit{ искомые коэффициенты} \vskip 0.3cm
 
 fi = [Symbol("fi(i)" k) for k in range(0,n)]  \vskip 0.3cm
 
\textit{ ядро, с подставленными в него точками вместо х  } \vskip 0.3cm
 
 fu = [K(xi[k],t) for k in range(0,n)] \vskip 0.3cm
 
\textit{ заменённый интеграл} \vskip 0.3cm
 R = [] \vskip 0.3cm
 for j in range(0,n): \vskip 0.3cm
 res  = sum((An(h,n)[k]*fu[j].subs(t,xi[k]))*fi[k] for k in range(0,n)) \vskip 0.3cm
 R.append(res) \vskip 0.3cm
 
\textit{ функция правой части, с подставленными в неё точками} \vskip 0.3cm
 
 fx = [f(xi[k]) for k in range(0,n)] \vskip 0.3cm
 
\textit{ система уравнений} \vskip 0.3cm
 
 system = [Eq(fi[k]+R[k],fx[k]) for k in range(0,n)] \vskip 0.3cm
 
\textit{ вычисление коэффициентов} \vskip 0.3cm
 
 coeffs = solve(system, fi) \vskip 0.3cm
 
\textit{ подстановка коэффициентов в приближенное решение} \vskip 0.3cm
 
 itog = f(x) - sum((An(h,n)[k]*K(x,t).subs(t,xi[k]))*fi[k] for k in range(0,n)) \vskip 0.3cm
 
 
 return itog.subs(coeffs)\\
 
 \textit{$ \bullet $    вычисляем результат для заданных пределов интегрирования и числа точек = n
 	}\\
 	
 x = Symbol('x') \vskip 0.3cm
                 t = Symbol('t') \vskip 0.3cm
                 a = 0 \vskip 0.3cm
                 b = 1 \vskip 0.3cm
                 n = 3 \vskip 0.3cm
                 
                 print(summa(x,t,a,b,n)) \\
                 
\includegraphics[width=17cm,height=1cm]{images/s4}                 
\textit{$ \bullet $                     Подставляем в найденное приближённое решение х = 0, х = 0.5, х = 1}\\

 $ fi_1 $ = summa(x, t, a, b, n).subs(x,'0').evalf() \vskip 0.3cm
 $ fi_2 $ = summa(x, t, a, b, n).subs(x,'0.5').evalf() \vskip 0.3cm
 $ fi_3 $ = summa(x, t, a, b, n).subs(x,'1').evalf() \vskip 0.3cm
 print(' | ', $ fi_1 $,' | ',$ fi_2 $,' | ',$ fi_3 $, ' | ')\\
 
\includegraphics[width=17cm,height=2cm]{images/s5}   \\
\newpage            
В результате видим относительно небольшую погрешность вычислений вручную. Теперь решим задачу для большего количества точек $ n = 10, \: 20, \: 30 $ . \\

\renewcommand{\arraystretch}{1.8} %% increase table row spacing
\renewcommand{\tabcolsep}{0.5cm}   %% increase table column spacing
\begin{table}[h!]
	\caption{\label{tab:canonsummary} Сравнение результатов вычисления}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			$ n \setminus x $ & 0 & 0.5 & 1\\
			\hline
			10 & 1.000000 & 0.999908 & 0.998618 \\
						\hline
			20 & 1.000000 & 0.999979 & 0.999688 \\
						\hline
			30 & 1.000000 & 0.999991 & 0.999866 \\
			\hline
		\end{tabular}
	\end{center}
\end{table} 

\newpage
\begin{center}
	\underline{Метод № 2}\\
	\begin{center}
		Найти решение того же интегрального уравнения:\\
		$$ y(x) + \int\limits_0^1 x(e^{xs}-1)y(s) ds = e^{x} - x  \quad  (\ast)$$\\
		методом замены ядра на вырожденное. 	
	\end{center}	
	\underline{Решенеие}\\
\end{center}

Ядро уравнения $ K(x,s) = x(e^{xs}-1) $ разложим в ряд Тейлора (возьмём первые три члена разложения). Тогда ядро примет вид:\\
$$ H(x,s) = x^2s + \frac{x^3s^2}{2} + \frac{x^4s^3}{6} ; $$\\

Поэтому вместо исходного уравнения будем решать интегральное уравнение, с заменённым ядром:\\
$$ z(x) + \int\limits_0^1 H(x,s)z(s)ds = e^x - x . \qquad \circledast$$\\
Его решение будем искать в виде:\\
$$ z(x) = e^x - x + C_1x^2 + C_2x^3 + C_3x^4 . $$\\

Подставляя $ z(x) $ в уравнение $ \circledast $ и интегрируя по отрезку [0,1], получим набор коэффициентов:\\

\begin{equation*}
\begin{cases}
(-\frac{1}{4}C_1 , - \frac{1}{5}C_2, - \frac{1}{6}C_3,) \\ 
(-\frac{1}{5}C_1, - \frac{7}{6}C_2, - \frac{1}{7}C_3,)\\
(-\frac{1}{6}C_1, - \frac{1}{7}C_2, - \frac{41}{8}C_3.)
\end{cases}
\end{equation*}\\

Для определения коэффициентов $ C_1, C_2, C_3 $,  основываясь на исследуемом методе, получим систему:\\
$$ C_i - \lambda\sum\limits_{j=1}^n \alpha_{ij}C_j = f_i \quad (i=1,2, ..., n).$$ \\
То есть в нашем случае имеем:\\

\begin{equation*}
\begin{cases}
\frac{5}{4}C_1 + \frac{1}{5}C_2 + \frac{1}{6}C_3 = -\frac{2}{3}, \\ 
\frac{1}{5}C_1 + \frac{13}{6}C_2 + \frac{1}{7}C_3 = \frac{9}{4} - e,\\
\frac{1}{6}C_1 + \frac{1}{7}C_2 + \frac{49}{8}C_3 = 2e -\frac{29}{5}.
\end{cases}
\end{equation*}\\
Решая систему, получим коэффициенты:\\
$$ C_1 = - 0,5010 ;  \quad  C_2 = -0,1671 ; C_3 = -0,0422 . $$\\
За приближенное решение уравнения $ (\ast) $ принимаем функцию:\\
$$ z(x) = e^x - x - 0,5010x^2 - 0,1671x^3 - 0,0422x^4 . $$\\
Подставляя в приближённое решение $ x = 0; \; x = 0,5; \; x =1 $, имеем:\\
$$ z(0) = 1. 0000 ; \quad z(0,5) = 0,99994627 ; \quad z(1) = 1,007981828 . $$\\
При этом точное решение данного интегрального уравнения $ \varphi(x) \equiv 1 . $ \\
\newpage
\begin{center}
	\textbf{Компьютерная реализация}
\end{center}

Вновь реализуем этот метод на языке Python, чтобы проверить ручные вычисления. Таксже, как и в случае Метода №1, построим таблицу, в которой сравним результаты для разного количества точек.\\

\begin{center}
	\underline{                                       Метод замены ядра на вырожденное}
\end{center}
from sympy import *\\
from mpmath import *\\
from numpy import *\\
from sympy import integrate, log, exp, cos, oo, sin\\
import math\\
from scipy.special import *\\
from sympy import symbols, diff\\
from numpy.polynomial import legendre as leg\\

\textit{$ \bullet $                                          Задаём функцию правой части} \vskip 0.3cm
def f(x): \vskip 0.3cm
return exp(x)-x\\

\textit{$ \bullet $                                                 Задаём ядро} \vskip 0.3cm
def K(x,t): \vskip 0.3cm
return x*(exp(x*t) - 1)\\

\textit{$ \bullet $                          Вычисление приближенного решения заменой ядра на вырожденное} \vskip 0.3cm
def Zamena(x, s, a, b, n): \vskip 0.3cm

\textit{Генерируем список искомых коэффициентов для уравнения} \vskip 0.3cm

ci = [Symbol("$ ci $"  k) for k in range(n+1)] \vskip 0.3cm

\textit{ Вычисляем разложение на матрицы Ai(x) и Bi(s)} \vskip 0.3cm

R = [] \vskip 0.3cm
for k in range(0,n+1): \vskip 0.3cm 
res  = ((1/factorial(k, exact=False))*(diff(K(x,s), x ,k)).subs(x,'0')) \vskip 0.3cm
R.append(res) \vskip 0.3cm

B = [] \vskip 0.3cm
for k in range(0,n+1): \vskip 0.3cm
res  = R[k]*(x**k) \vskip 0.3cm 
B.append(res.subs(s,'1')) \vskip 0.3cm

N = [] \vskip 0.3cm
for k in range(0,n+1): \vskip 0.3cm
r  = B[k] \vskip 0.3cm
N.append(r.subs(x,'1')) \vskip 0.3cm

M = [] \vskip 0.3cm
for k in range(0,n+1): \vskip 0.3cm
if B[k] == 0: \vskip 0.3cm
ir = N[k] \vskip 0.3cm
else: \vskip 0.3cm
ir  = B[k]*N[k]**(-1) \vskip 0.3cm
M.append(ir) \vskip 0.3cm

D = [] \vskip 0.3cm 
for k in range(0,n+1): \vskip 0.3cm
if R[k] == 0: \vskip 0.3cm
d = N[k] \vskip 0.3cm
else: \vskip 0.3cm 
d  = R[k]*N[k]**(-1) \vskip 0.3cm
D.append(d) \vskip 0.3cm

An = [] \vskip 0.3cm
for k in range(0,n+1): \vskip 0.3cm
h  = M[k]*ci[k] \vskip 0.3cm
An.append(h) \vskip 0.3cm

\textit{решение ищем в виде} \vskip 0.3cm

itog = f(x) + sum((M[k]*ci[k] for k in range(0,n+1))) \vskip 0.3cm

\textit{Вычисляем коэффициенты правой части}

$ eq_2 $ = [integrate(f(s)*D[k], (s, a, b)) \
for k in range(0,n+1)] \vskip 0.3cm

\textit{Вычисляем левую часть} \vskip 0.3cm

V = [] \vskip 0.3cm
for j in range(0,n+1): \vskip 0.3cm
$ eq_3 $ = sum(integrate(M[k].subs(x,s)*D[j]*ci[k], (s, a, b)) \ for k in range(0,n+1)) \vskip 0.3cm
V.append($ eq_3 $) \vskip 0.3cm

it = [An[k].subs(x,'1') for k in range(0,n+1)] \vskip 0.3cm

\textit{ Генерируем систему уравнений} \vskip 0.3cm

System = [] \vskip 0.3cm
for k in range(0,n+1): \vskip 0.3cm
if (it[k] == 0):  \vskip 0.3cm
continue \vskip 0.3cm
elif (V[k] == 0): \vskip 0.3cm
continue \vskip 0.3cm
else: \vskip 0.3cm
system = Eq(it[k] + V[k],-$ eq_2 $[k]) \vskip 0.3cm
System.append(system) \vskip 0.3cm

\textit{Решаем систему и находим коэффициенты} \vskip 0.3cm

coeffs = solve(System, ci) \vskip 0.3cm

return itog.subs(coeffs) \vskip 0.3cm

\textit{$ \bullet $                     Вычисляем результат для заданных пределов интегрирования и числа точек = n} \vskip 0.3cm

x = Symbol('x') \vskip 0.3cm
t = Symbol('t') \vskip 0.3cm
s = Symbol('s') \vskip 0.3cm

a = 0 \vskip 0.3cm
b = 1 \vskip 0.3cm
n = 4 \vskip 0.3cm

print(Zamena(x,s,a,b,n)) \vskip 0.3cm

\includegraphics[width=17cm,height=0.9cm]{images/v1}           

\textit{$ \bullet $                     Подставляем в найденное приближённое решение х = 0, х = 0.5, х = 1} \vskip 0.3cm

$ fi_1 $ = Zamena(x,s,a,b,n).subs(x,'0').evalf() \vskip 0.3cm
$ fi_2 $ = Zamena(x,s,a,b,n).subs(x,'0.5').evalf() \vskip 0.3cm
$ fi_3 $ = Zamena(x,s,a,b,n).subs(x,'1').evalf() \vskip 0.3cm
print(' | ', $ fi_1 $,' | ',$ fi_2 $,' | ',$ fi_3 $, ' | ') \\

\includegraphics[width=17cm,height=1cm]{images/v2}  \\

Можем наблюдать, что уравнение совпадает, коэффициенты отличаются незначительно. Решим эту задачу для точек $ n = 10, \: 20, \: 30 $.\\

\renewcommand{\arraystretch}{1.8} %% increase table row spacing
\renewcommand{\tabcolsep}{0.5cm}   %% increase table column spacing
\begin{table}[h!]
	\caption{\label{tab:canonsummary} Сравнение результатов вычисления}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			$ n \setminus x $ & 0 & 0.5 & 1\\
			\hline
			10 & 1.000000 & 0.999968 & 1.008461 \\
			\hline
			20 & 1.000000 & 0.999971 & 1.008668 \\
			\hline
			30 & 1.000000 & 0.999981 & 1.008766 \\
			\hline
		\end{tabular}
	\end{center}
\end{table} 
               
\newpage               
\begin{center}
	\underline{Метод № 3}\\
	\begin{center}
		Найти решение интегрального уравнения:\\
		$$ \varphi(x) + \int\limits_0^1 x(e^{xt}-1)\varphi(t) dt = e^{x} - x  \quad  (\ast)$$\\
		методом Бубнова-Галёркина. 	
	\end{center}	
	\underline{Решенеие}\\
\end{center}

В качестве полной системы функций на $ [0,1] $ выберем систему сдвинутых полиномов Лежандра $ P_n(x) = \left\lbrace 1; 2x-1; 6x^2 - 6x+1; ... \right\rbrace  $ $ \quad (n = 0,1,2,...) $. Приближенное решение $ \varphi_n(x) $ уравнения $ (\ast) $ будем искать в виде:\\
$$ \varphi_3(x) = \sum\limits_{k=1}^n a_ku_k(x) = a_1 + a_2(2x-1) + a_3(6x^2 -6x+1); $$\\
$$ \varphi(x) = e^{x} - x - \int\limits_0^1 x(e^{xt}-1)\varphi(t) dt   $$\\
Подставляя $  \varphi_3(x) $ вместо $  \varphi(x) $ в уравнение  $(\ast)$ , будем иметь:\\
$$ a_1 + a_2(2x-1) + a_3(6x^2 -6x+1) =$$\\
$$= e^{x} - x - \int\limits_0^1 x(e^{xt}-1)(a_1 + a_2(2t-1) + a_3(6t^2 -6t+1)) dt $$\\
Упростим правую часть и перепишем уравнение в виде:\\
$$ a_1 + a_2(2x-1) + a_3(6x^2 -6x+1) =$$\\
$$= e^x - x - a_1(e^x - x - 1) - a_2(e^x(2x-1)-2x^2 + x + 1) - a_3(e^x(6x^2 - 6x + 1) - 6x^3 + 5x - 1) ;  $$\\
Умножая обе части этого уравнения последовательно на $ 1; 2x-1; 6x^2 - 6x+1 $ и интегрируя по $ x $ в пределах от $ 0 $ до $ 1 $, найдём:\\
\begin{equation*}
\begin{cases}
a_1 = 1,2182 - (e - \frac{5}{2})a_1 - (\frac{13}{3}-e)a_2 - (7e-19)a_3 , \\ 
\frac{1}{3}a_2 = 0,11505 - (\frac{17}{6} - e)a_1 - (5e - \frac{79}{6})a_2 - (\frac{1754}{15}-43e)a_3 ,\\
\frac{1}{5}a_3 = 0,02797 - (7e - 19)a_1 - (\frac{1754}{15} - 43e)a_2 - (517e - \frac{14053}{10})a_3 .
\end{cases}
\end{equation*}\\
Иначе:\\
\begin{equation*}
\begin{cases}
a_1 = 1,2182 - 0,2183a_1 - 1,6150a_2 - 0,0279a_3 , \\ 
\frac{1}{3}a_2 = 0,11505 - 0,1150a_1 - 0,4247a_2 - 0,0472a_3 ,\\
0,2a_3 = 0,02797 - 0,0279a_1 - 0,0472a_2 - 0,0517a_3 .
\end{cases}
\end{equation*}\\
Решая данную систему, получим коэффициенты:\\
$$ a_1 = 0,9998; \quad a_2 = 0,0007719; \quad a_3 = 0,0002847 . $$\\
Значит, приближенное решение имеет вид:\\
$$ \varphi_3(x) = 0,9998 + 0,0007719(2x-1) + 0,0002847(6x^2-6x+1); $$\\
или\\
$$ \varphi_3(x) = 0,0017082x^2 - 0,0001644x + 0, 9993128 . $$\\
Из найденного приближенного решения при $ x = 0; \; x = 0,5; \; x =1 $, имеем:\\
$$ \varphi_3(0) = 0,9993128 ; \quad \varphi_3(0,5) = 0,99965765 ; \quad \varphi_3(1) = 1,0008566 . $$\\
Точное решение данного интегрального уравнения $ \varphi(x) \equiv 1 . $ \\
\newpage
\begin{center}
	\textbf{Компьютерная реализация}
\end{center}

На языке Python опишем реализацию данного метода.Как и в случаях Методов №1 и №2, построим таблицу, в которой сравним результаты для разного количества точек.\\

\begin{center}
	\underline{Метод Бубнова-Галёркина}
\end{center}
from sympy import *\\
from mpmath import *\\
from numpy import *\\
from sympy import integrate, log, exp, cos, oo\\
import math\\
from scipy.special import *\\
from sympy import symbols, diff\\
from numpy.polynomial import legendre as leg\\

\textit{$ \bullet $                                     Сдвинутые полиномы Лежандра} \vskip 0.3cm

def Ln(x, n): \vskip 0.3cm
return simplify((1/factorial(n, exact=False))*diff((x**2 - x)**n, x ,n)) \vskip 0.3cm

\textit{$ \bullet $                                          Задаём функцию правой части} \vskip 0.3cm
def f(x): \vskip 0.3cm
return exp(x)-x\\

\textit{$ \bullet $                                                 Задаём ядро} \vskip 0.3cm
def K(x,t): \vskip 0.3cm
return x*(exp(x*t) - 1)\\

\textit{$ \bullet $                     Задаём функцию, решающую уравнение методом Бубнова-Галёркина} \vskip 0.3cm

def BubnovGalerkin(x, t, x0, x1, q): \vskip 0.3cm

\textit{Задаём базисные функции} \vskip 0.3cm

basis = [Ln(x,k) for k in range(q+1)] \vskip 0.3cm

\textit{Генерируем коэффициенты для искомого приближённого решения} \vskip 0.3cm

xi = [Symbol("xi"  k) for k in range(q+1)] \vskip 0.3cm

\textit{ Приближённое решение будет иметь вид} \vskip 0.3cm

u = sum(xi[k]*basis[k] for k in range(0,q+1))

\textit{наше фи будет иметь вид обычной функции (без преобразований)   } \vskip 0.3cm

ode = lambda u: u \vskip 0.3cm

\textit{ Проинтегрировали умноженное на фи от т ядро } \vskip 0.3cm

Int = integrate(K(x,t)*(ode(u).subs(x,t)), (t, x0, x1)) \vskip 0.3cm

\textit{Умножаем поэлементно на к-ый элемент базиса каждую часть уравнения и интегрируем по х} \vskip 0.3cm

$ eq_1 $ = [integrate(ode(u)*basis[k], (x, x0, x1)) \
for k in range(0,q+1)] \vskip 0.3cm

$ eq_2 $ = [integrate(f(x)*basis[k], (x, x0, x1)) \
for k in range(0,q+1)] \vskip 0.3cm

$ eq_3 $ = [integrate(Int*basis[k], (x, x0, x1)) \
for k in range(0,q+1)] \vskip 0.3cm


\textit{Составляем систему уравнений } \vskip 0.3cm

system = [Eq($ eq_1 $[k]+$ eq_3 $[k],$ eq_2 $[k]) for k in range(0,q+1)] \vskip 0.3cm

\textit{Решаем полученные системы и получаем коэффициенты} \vskip 0.3cm
coeffs = solve(system, (xi)) \vskip 0.3cm

\textit{Подставляем эти коэффициенты в приближенное решение} \vskip 0.3cm
return u.subs(coeffs)\\

\textit{$ \bullet $                 Задаём параметры и проверяем работу функции (получаем вид приближённого решения)} \vskip 0.3cm

x = Symbol('x') \vskip 0.3cm
t = Symbol('t') \vskip 0.3cm
a = 0 \vskip 0.3cm
b = 1 \vskip 0.3cm
n = 3 \vskip 0.3cm

pprint(BubnovGalerkin(x, t, a, b, n)) \vskip 0.3cm

\includegraphics[width=17cm,height=1cm]{images/b1}  \\

\textit{$ \bullet $                     Подставляем в найденное приближённое решение х = 0, х = 0.5, х = 1} \vskip 0.3cm

$ fi_1 $ = BubnovGalerkin(x, t, a, b, n).subs(x,'0').evalf() \vskip 0.3cm
$ fi_2 $ = BubnovGalerkin(x, t, a, b, n).subs(x,'0.5').evalf() \vskip 0.3cm
$ fi_3 $ = BubnovGalerkin(x, t, a, b, n).subs(x,'1').evalf() \vskip 0.3cm
print(' | ', $ fi_1 $,' | ',$ fi_2 $,' | ',$ fi_3 $, ' | ') \\

\includegraphics[width=18cm,height=0.8cm]{images/b2}  \\

Уравнение имеет тот же вид, а его коэффициенты практически идентичны. Решим эту задачу для точек $ n = 10, \: 20, \: 30 $.\\

\renewcommand{\arraystretch}{1.8} %% increase table row spacing
\renewcommand{\tabcolsep}{0.5cm}   %% increase table column spacing
\begin{table}[h!]
	\caption{\label{tab:canonsummary} Сравнение результатов вычисления}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			$ n \setminus x $ & 0 & 0.5 & 1\\
			\hline
			10 & 0.999410 & 0.999791 & 1.000910 \\
			\hline
			20 & 0.999410 & 0.999801 & 1.000931 \\
			\hline
			30 & 0.999410 & 0.999867 & 1.000954 \\
			\hline
		\end{tabular}
	\end{center}
\end{table} 

\newpage

Рассмотрим ещё два примера, точное решение которых известно, с целью выяснить, какой из методов даёт наиболее точное приближённое решение.\\
\begin{center}
	\underline{Интегральное уравнение №1}
\end{center}

$$\varphi(x) - \int\limits_{-1}^{1} xt\varphi(t)dt = x.$$

Точное решение данного интегрального уравнения $ \varphi(x) = 3x ,$ в чём легко убедиться, подставив его в уравнение. Тогда точное его значение в точках $ x = 0, \: x = 0.5, \: x = 1 $ должно быть соответсвенно равно $ 0, \: 1.5, \:  3. $\\

Рассмотрим таблицу, в которой сравниваются все три метода для данного интегрального уравнения для разного количества точек (Таблица 4).\\

\newpage

\renewcommand{\arraystretch}{1.5} %% increase table row spacing
\renewcommand{\tabcolsep}{0.1cm}   %% increase table column spacing

\begin{table}[h!]
	\caption{\label{tab:canonsummary} Сравнение методов}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Точка $ x $ & \multicolumn{3}{|c|}{Методы} \\
			\hline
			 & Замена интеграла& Замена ядра& Метод\\
			 & конечной суммой & на вырожденное & Бубнова-Галёркина\\			 
			\hline
			\multicolumn{4}{|c|}{$ n = 5 $} \\
			\hline
			0 & 0 & 0 & 0 \\
			\hline
			0.5 & 1.28571& 1.46014 & 1.48103 \\
			\hline
			1 & 2.57142 & 2.70157 & 2.86018 \\
			\hline
			\multicolumn{4}{|c|}{$ n = 10 $} \\
			\hline
			0 & 0 & 0 & 0 \\
			\hline
			0.5 & 1.29706 & 1.46941 & 1.48670 \\
			\hline
			1 & 2.59413 & 2.79147 & 2.89044 \\
			\hline
			\multicolumn{4}{|c|}{$ n = 20 $} \\
			\hline
			0 & 0 & 0 & 0 \\
			\hline
			0.5 & 1.29933 & 1.47352 & 1.48991 \\
			\hline
			1 & 2.59867 & 2.83017 & 2.92733 \\
			\hline
			\multicolumn{4}{|c|}{$ n = 30 $} \\
			\hline
			0 & 0 & 0 & 0 \\
			\hline
			0.5 & 1.29971 & 1.48407 & 1.490054 \\
			\hline
			1 & 2.59942 & 2.89613 & 2.94511 \\						
			\hline
		\end{tabular}
	\end{center}
\end{table} 

\newpage
\begin{center}
	\underline{Интегральное уравнение №2}
\end{center}

$$\varphi(x) - \int\limits_{-1}^{1} (xt + x^2)\varphi(t)dt = 1.$$

Точное решение данного интегрального уравнения $ \varphi(x) = 6x^2 + 1 ,$ в чём легко убедиться, подставив его в уравнение. Тогда точное его значение в точках $ x = 0, \: x = 0.5, \: x = 1 $ должно быть соответсвенно равно $ 0, \: 2.5, \:  7. $\\

Рассмотрим таблицу, в которой сравниваются все три метода для данного интегрального уравнения для разного количества точек (Таблица 5).\\

\newpage
\renewcommand{\arraystretch}{1.5} %% increase table row spacing
\renewcommand{\tabcolsep}{0.1cm}   %% increase table column spacing
\begin{table}[h!]
	\caption{\label{tab:canonsummary} Сравнение методов}
	\begin{center}
		\begin{tabular}{|c|c|c|c|}
			\hline
			Точка $ x $ & \multicolumn{3}{|c|}{Методы} \\
			\hline
			& Замена интеграла& Замена ядра& Метод\\
			& конечной суммой & на вырожденное & Бубнова-Галёркина\\			 
			\hline
			\multicolumn{4}{|c|}{$ n = 5 $} \\
			\hline
			0 & 1 & 1 & 1 \\
			\hline
			0.5 & 2.38041 & 2.47872 & 2.48271 \\
			\hline
			1 & 6.59042 & 6.78014 & 6.88210 \\
			\hline
			\multicolumn{4}{|c|}{$ n = 10 $} \\
			\hline
			0 & 1 & 1 & 1 \\
			\hline
			0.5 & 2.38403 & 2.48004 & 2.48704 \\
			\hline
			1 & 6.59408 & 6.78994 & 6.89993 \\
			\hline
			\multicolumn{4}{|c|}{$ n = 20 $} \\
			\hline
			0 & 1 & 1 & 1 \\
			\hline
			0.5 & 2.39004 & 2.48310 & 2.49423 \\
			\hline
			1 & 6.60186 & 6.79315 & 6.94990 \\
			\hline
			\multicolumn{4}{|c|}{$ n = 30 $} \\
			\hline
			0 & 1 & 1 & 1 \\
			\hline
			0.5 & 2.39618 & 2.48813 & 2.499704 \\
			\hline
			1 & 6.63048 & 6.79949 & 6.97906 \\						
			\hline
		\end{tabular}
	\end{center}
\end{table} 

Таким образом, видим, что наименьшую точность дал метод "Замены интеграла конечной суммой", а наибольшую - " Метод Бубнова-Галёркина".

\newpage
\begin{center}
	\underline{Метод № 4}\\
\end{center}
Имеем интегральное уравнение:
$$u(x) - \int\limits_X K(x, y)u(y)dy = \varphi(x),$$
где $ x, y \in \mathbb{R}^n $, $ K(x,y) -$скалярное произведение $ x $ и $ y $ , $ \varphi(x) -$скалярный квадрат $ x $. \\
\begin{center}
	\textit{Решим его методом Бубнова-Галёркина, используя нейронные сети.}
\end{center}
Ищем приближенное решение в виде:
$$u(x) \approx\sum_{i=0}^n c_i e_i(x),$$
где $ e_i(x) -$ нейроны (базисные векторы).\\
Подставим приближенное решение в уравнение:
$$\sum_{i=0}^n c_j e_j(x) - \int\limits_X K(x, y)\left[\sum_{j=0}^n c_j e_j(y)\right]dy = \varphi(x),$$
или
$$\sum_{j=0}^n c_j e_j(x) - \sum_{j=0}^n c_j \int\limits_X K(x, y)e_j(y)dy = \varphi(x).$$
Умножим левую и правую части уравнения на $e_i(x)$, $i=0,1,\ldots,n$, и проинтегрируем по $x$:
$$\sum_{j=0}^n c_j\int\limits_X e_j(x)e_i(x)dx - \sum_{j=0}^n c_j \int\limits_X\int\limits_X K(x, y)e_i(x)e_j(y)dxdy = \int\limits_X\varphi(x)e_i(x)dx,\,\,i=0,1,\ldots,n.$$
Мы получили систему линейных уравнений относительно коэффициентов $c_i$. $i,j$-йэлемент матрицы этой системы равен
$$\int\limits_X e_j(x)e_i(x)dx - \int\limits_X\int\limits_X K(x, y)e_i(x)e_j(y)dxdy,$$ а $i$-й элемент вектора правых частей равен
$$\int\limits_X\varphi(x)e_i(x)dx.$$
Решая систему, найдем коэффициенты $c_i$ и тем самым приближенное решение.\\
\newpage
\begin{center}
		\textbf{Компьютерная реализация}
\end{center}
import pandas as pd\\
import random as rnd\\
from matplotlib import pyplot as plt\\
from matplotlib import mlab\\
import numpy as np\\
from numpy import linalg as la\\
import numpy as np\\
import scipy as sp\\
from scipy import optimize as opt\\
from scipy.optimize import basinhopping\\
from scipy.optimize import differentialevolution\\
import math\\
from sympy import symbols, diff\\
from sympy import *\\

\textit{$ \bullet $ Задаём размерность нашего пространства (векторов) и его границы:} \vskip 0.3cm

s = 2 \vskip 0.3cm
bounds = np.array([[-1, 1] for i in range(s)]) \vskip 0.3cm

\textit{$ \bullet $     Задаём количество нейронов} \vskip 0.3cm

n = 10 \vskip 0.3cm

\textit{$ \bullet $                                         Функция, которая высчитывает ядро} \vskip 0.3cm

def k1(x, y): \vskip 0.3cm
return np.dot(x, y)  \vskip 0.3cm

K = k1 \vskip 0.3cm

\textit{$ \bullet $  Функция правой части} \vskip 0.3cm

def phi1(x): \vskip 0.3cm
return np.dot(x, x) \vskip 0.3cm

phi = phi1 \vskip 0.3cm

\textit{$ \bullet $  Генерируем векторы x0} \vskip 0.3cm

x0 = np.array([[rnd.random() * (bounds[j][1] - bounds[j][0]) + bounds[j][0] for j in range(s)] for i in range(n)]) \vskip 0.3cm

\textit{$ \bullet $      Генерируем векторы w} \vskip 0.3cm

w = np.array([[rnd.random() for j in range(s)] 
for i in range(n)]) \vskip 0.3cm

\textit{Именно набор пар точек (x0, w) определяет набор базисных функций (нейронов) } \vskip 0.3cm

\textit{$ \bullet $                               Функция, вычисляющая i-ю базисную функцию (тождественная единица при i=0 и нейрон при i>0) } \vskip 0.3cm

def neuron(i, x):  \vskip 0.3cm          
if i == 0: \vskip 0.3cm
return 1 \vskip 0.3cm
else:  \vskip 0.3cm
return float(np.dot(w[i-1], x-x0[i-1])>0) \vskip 0.3cm

e = neuron \vskip 0.3cm

Интегралы будем вычислять методом Монте-Карло. Число узлов (точек) обозначим $m$. \\

m = 100 \vskip 0.3cm

Вычислим эти узлы: \vskip 0.3cm

xForInt = np.array([[rnd.random() * (bounds[j][1] - bounds[j][0]) + bounds[j][0] for j in range(s)] 
for i in range(m)]) \vskip 0.3cm

Вычислим меру области задания функций: \vskip 0.3cm

meas = np.prod([bounds[j][1] - bounds[j][0] for j in range(s)]) \vskip 0.3cm

def integralofeiej(e, i, j): \vskip 0.3cm
return meas * np.mean(np.array([e(i, x) * e(j, x) for x in xForInt])) \vskip 0.3cm

Для вычисления двойного интеграла нужна еще одна серия узлов: \vskip 0.3cm

xforint2 = np.array([[rnd.random() * (bounds[j][1] - bounds[j][0]) + bounds[j][0] for j in range(s)] 
for i in range(m)])  \vskip 0.3cm

def integralofKeiej(K, e, i, j): \vskip 0.3cm
return meas**2 * np.mean(np.array([[K(x, y) * e(i, x) * e(j, x) for x in xForInt] for y in xforint2])) \vskip 0.3cm

Вычислим левую часть: \vskip 0.3cm

matrix = [[integralofeiej(neuron, i, j) - integralofKeiej(K, neuron, i, j) for j in range(n+1)] for i in range(n+1)] \vskip 0.3cm

def integralofeiphi(e, i, phi): \vskip 0.3cm
return meas * np.mean(np.array([e(i, x) * phi(x) for x in xForInt])) \vskip 0.3cm

Вычислим правую часть: \vskip 0.3cm

rightSide = [integralofeiphi(neuron, i, phi)  for i in range(n+1)] \vskip 0.3cm

Найдем коэффициенты $c_i$: \vskip 0.3cm

c = np.linalg.solve(matrix, rightSide) \vskip 0.3cm
print(c) 
\begin{center}
	\textit{Искомые коэффициенты}
\end{center}

\includegraphics[width=18cm,height=1cm]{images/n1}  \\



%%%%%%%%%%%%%%%%%%%%%

\begin{center}
\underline{	Генерируем сетку точек для проверки решения:}
\end{center}

mTest = 5 \vskip 0.3cm

xfortest = np.array([[rnd.random() * (bounds[j][1] - bounds[j][0]) + bounds[j][0] for j in range(s)] for i in range(mTest)]) \vskip 0.3cm
for i in range(0,mTest): \vskip 0.3cm
print(xfortest[i]) \vskip 0.3cm
Получим набор точек, для которых найдём приближённое решение, используя нейроны:

\includegraphics[width=18cm,height=3cm]{images/n2}  \\

def ApproximateSolution(e, c, x): \vskip 0.3cm
return sum([c[i ]* e(i, x) for i in range(n+1)]) \vskip 0.3cm

for i in range(0,mTest):  \vskip 0.3cm
print(ApproximateSolution(neuron, c, xfortest[i])) \\

Получаем приближённое решение в виде: \\
$$u(x) \approx\sum_{i=0}^n c_i e_i(x),$$
\newpage
т.е. с подставленными коэффициентами и значениями точек $ x $:\\

\includegraphics[width=18cm,height=3cm]{images/n3}  \\














\newpage
\begin{center}
	\textbf{Заключение}\\
\end{center}

В ходе курсовой работы были рассмотрены три основных метода приближенного решения интегральных уравнений Фредгольма второго рода, а именно: замена интеграла конечной суммой, замена ядра на вырожденное, метод Бубнова-Галеркина.\\

Для функции одной переменной были рассмотрены все три метода поиска приближённого решения и проведенео сравнение результатов, при увеличении размерности систем( через увеличение числа точек). Для функции нескольких переменных, был рассмотрен метод Бубнова-Галёркина, где в качестве базисных функций рассматривались нейроны.\\

Сравнение точного решения интегрального уравнения и результатов, полученных при решении тремя методами показали, что методы дают приближенное решение. При увеличении количества точек (увеличении размерности решаемых систем), решение приближается к истинному и погрешность становится невелика.  \\

Решение данных задач помогло более глубоко и основательно изучить и закрепить на практике теоретический материал.\\



\newpage
\begin{center}
	\textbf{Список литературы}\\
\end{center}

1.  Курс высшей математики: учебное пособие / сост.: В. И. Смирнов - 6-е изд., 4-ый том, 1-ая часть, перераб. и доп. - Москва : Наука, 1974 г. - 336 с.\\

2. Приближенные методы решения дифференциальных и интегральных уравнений: учебное пособие / сост.: Михлин С.Г., Смолицкий Х.Л. - перераб. и доп. - Москва: Наука, 1965. — 384 с. \\

3. Интегральные уравнения: учебное пособие / сост.: Краснов М.Л., Киселев А.И., Макаренко Г.И.  - Москва: Наука, 1968. — 192 с.\\

4. Задачи и упражнения по функциональному анализу: учебное пособие / сост.: Антоневич А. Б., Князев П. Н., Радыно Я. В. - Минск: Вышэйшая школа, 1978 \\

5. Интегралы и ряды элемнтарные функции: учебное пособие / сост.:  Прудников А.П.,Брычков Ю.А., Маричев О.И. - Владикавказ: СОГУ, 1981\\

6. Дифференциальные и интегральные уравнения, вариационное исчисление в примерах и задачах.: учебное пособие / сост.: Васильева А. Б., Тихонов Н.А. - Новосибирск: Наука, 1983 \\

7. Интегральные уравнения: учебное пособие / сост.: Васильева А. Б., Тихонов Н.А. - Новосибирск: Наука, 1986 \\

8. Интегральные уравнения: Задачи и примеры с подробными решениями: Учебное пособие. Изд. 3-е / сост.: А.И. Киселев, М.Л. Краснов, Г.И. Макаренко, испр. - М.: Едиториал УРСС, 2003. -192 с. (Вся высшая математика в задачах.)\\

9. Методы вычислений, т. II : учебное пособие /сост.: И.С. Березин, Н.П. Жидков,- Москва, Государственное издательство физико-математической литературы, 1959


\end{document}	